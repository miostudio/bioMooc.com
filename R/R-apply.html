<!Doctype html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>R 教程 | 生物慕课网</title>

<link rel="canonical" href="http://www.biomooc.com/R/R-tutorial.html" />
<meta name="keywords" content="R 绘图教程,R低水平绘图命令">
<meta name="description" content="R 绘图教程,R低水平绘图命令。">
		
	<link rel="shortcut icon" href="/img/favicon.ico" mce_href="/img/favicon.ico" type="image/x-icon" >
	<link rel="stylesheet" href="/wp-content/themes/biomooc/style.css?v=1.141" type="text/css" media="all" />	
	<link rel="stylesheet" href="/static/css/font-awesome.min.css" media="all" />	
<!--
	<link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" media="all" />	  
-->
  <!--[if gte IE 9]><!-->
  <script src="/static/js/jquery.min.js"></script>
  <!--<![endif]-->
  <!--[if lt IE 9]>
     <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
     <script src="//cdn.bootcss.com/html5shiv/r29/html5.min.js"></script>
  <![endif]-->
  <link rel="apple-touch-icon" href="/img/mobile-icon.png"/>
  <meta name="apple-mobile-web-app-title" content="生物慕课网">

</head>


<body>
<!-- 头尾自动加载 -->
<script>
$(function(){
	$.get('/part/header-nav.html',function(data,status){
		$('body').prepend(data);//header-nav
	});
	
	$('<div id="footer" class="mar-t50"></div>').appendTo($("body"));
	$("#footer").load("/part/footer.html"); //footer
	
	$.get('/part/right-bottom-btn.html',function(data,status){
		$('#footer').after(data);//右下角按钮
	});

	
			
	//左右菜单
	$.get('./part/menu-left.html',function(data,status){
		$('.main .row').first().prepend(data);//左侧菜单-本文件夹内使用
	});
	
	$.get('/part/menu-right.html',function(data,status){
		$('.main .row').first().append(data);//右侧菜单-全局通用
		//没有事件，还需要绑定事件
		
		
	});
	
	$.getScript("/wp-content/themes/biomooc/assets/js/main.js?v=1.15");//回到顶部js文件
});
</script>


	
	

<!--  内容  -->
<div class="container main">
	<!-- 中间 -->
	<div class="row">
	





<div class="col middle-column">
		
	
	<div class="article">
			<div class="article-heading-ad" style="display: none;">
		
		</div>
		<div class="previous-next-links">
			<div class="previous-design-link"><i style="font-size:16px;" class="fa fa-arrow-left" aria-hidden="true"></i> <a href="/R/R-intro.html" rel="pre">R 简介</a> </div>
			<div class="next-design-link"><a href="/R/R-intro.html" rel="next"> R 简介</a> <i style="font-size:16px;" class="fa fa-arrow-right" aria-hidden="true"></i></div>
		</div>
		<div class="article-body">
		
			<div class="article-intro" id="content">
			
			<h1><span class="color_h1">R apply家族函数 </span> 详解</h1>



<h2 class="tutheader">目录</h2>
<p><b>要点</b>: 要想快速，就要尽量避免在R中使用for循环，用向量化的思维处理数据框。[R In Action,2nd: mainly in Chapter5.3]</p>

<ul>
	<li><a href="#0">apply家族函数概述</a></li>
	<li><a href="#1">apply(X, MARGIN, FUN, ...)</a>
		<ul>
			<li><a href="#12">自定义函数</a>
			<li><a href="#13">apply中使用if</a>
		</ul>
	</li>
	
	<li><a href="#2">lapply, 对list使用fn，并返回list (sapply返回矩阵)</a>
		<ul>
			<li><a href="#22">按照条件f拆分x: split(x, f, drop = FALSE, ...)</a>
			<li><a href="#23">sapply函数返回矩阵(simple apply)</a>
			<li><a href="#24">vapply, 类似sapply，FUN.VALUE参数可控制返回值的行名</a>
			<li><a href="#25">mapply, 是sapply的多变量版本，第一个参数是函数，后面能接收多个输入数据//todo</a>
		</ul>
	</li>
	<li><a href="#3">tapply: table(), by() //todo</a>
		<ul>
			<li><a href="#31">gl() 产生因子/函数table（求因子出现的频数）//todo</a>
			<li><a href="#32">by(dataframe, INDICES, FUN, ..., simplify=TRUE)//todo</a>
		</ul>
	</li>
	<li><a href="#4">rapply, 递归版本的lapply，只处理list类型数据//todo</a></li>
	<li><a href="#5">eapply, 对环境内的所有变量批量(开发R包用)//todo</a></li>
	
</ul>

<p><b>在使用R时，要尽量用array的方式思考，避免for循环。</b></p>
<p><b>重点: base包中split – apply – combine 数据处理模式。</b></p>
<p>R是一种面向数组(array-oriented)的语法，它更像数学，方便科学家将数学公式转化为R代码。apply族功能强大，实用，可以代替很多循环语句。因为向量在R中在底层用C语言优化过，运行更快，性能更好，在使用R时，要尽量用array的方式思考，避免for、while循环语句，特别是数据量大的时候。</p>
<br>
<p>apply函数族是R语言中数据处理的一组核心函数，通过使用apply函数，我们可以实现对数据的循环、分组、过滤、类型控制等操作。但是，由于在R语言中apply函数与其他语言循环体的处理思路是完全不一样的，所以apply函数族一直是使用者玩不转的一类核心函数。很多R语言新手，写了很多的for循环代码，也不愿意多花点时间把apply函数的使用方法了解清楚，最后把R代码写的跟C似的，只会写for的R程序员的代码是效率低下的，是被鄙视的。</p>


<a name='0'></a>
<h2 class="tutheader">apply家族函数概述</h2>
<p>不用循环怎么实现迭代呢？这就需要用到 apply 函数族。它不是一个函数，而是一族功能类似的函数。</p>
<p>apply族函数是高效能计算的运算向量化(Vectorization)实现方法之一。常用的向量操作就是apply的家族函数：apply, sapply, tapply, mapply, lapply, rapply, vapply, eapply等。</p>








<br><a name="1"></a>
<h2 class="tutheader">apply(X, MARGIN, FUN, ...)</h2>
<p>X是数据框，margin只能是1(by row)或2(by column), fun是要应用的方程。</p>
<p>用apply可以很方便地按行列求和/平均，其结果与colMeans,colSums,rowMeans,rowSums是一样的。</p>

<div class="code notranslate">
	<div style="white-space: pre-wrap;">#例1：比如，对一个数据框每一列求平均数，下面就要用到apply做循环了。
x=data.frame(cell1=c(10,20,15,26,30),cell2=c(100,180,160,179,40))
rownames(x)=paste0("gene",1:5)
x
#       cell1 cell2
# gene1    10   100
# gene2    20   180
# gene3    15   160
# gene4    26   179
# gene5    30    40

apply(x,2,mean) #按列计算均值
#cell1 cell2 
# 20.2 131.8

apply(x,1,mean) #按行
#gene1 gene2 gene3 gene4 gene5 
# 55.0 100.0  87.5 102.5  35.0 

## 最后的函数可以使用
apply(x,1,sum) #求和
apply(x,1,median) #中位数
apply(x,1,sd) #标准差，方差的开方
apply(x,1,var) #方差
apply(x,1,max) #最大值
apply(x,1,min) #最小值
apply(x,1,fivenum) #数据的分位数
apply(x,1,cumsum) #累加
t(apply(x,1,function(x)x**2)) #每个元素分别求平方



## apply的返回值是 named number，可以通过自定义函数变为数据框
## 实现了添加列名、按值排序、输出行列、前几行;
getDF_fromNamesXX=function(namedXX,debug=F){
  rs=data.frame(
    name=names(namedXX),
    value=as.numeric(namedXX)
  )
  row.names(rs)=rs$name
  rs=rs[order(-rs$value),]
  if(debug==T){
	print(dim(rs))
	print(head(rs))
  }
  return(rs)
}

getDF_fromNamesXX(apply(x,1,mean))
#        name value
# gene4 gene4 102.5
# gene2 gene2 100.0
# gene3 gene3  87.5
# gene1 gene1  55.0
# gene5 gene5  35.0</div>
</div>





<br><a name="12"></a>
<h3 class="tutheader">自定义函数</h3>
<p>如果现有函数无法满足需要，还可以自定义函数。</p>

<div class="code notranslate">
	<div style="white-space: pre-wrap;"># 例2: 按列进行标准化，相当于求cpm
> cpm=apply(x,2,function(x){x/sum(x)*1e6})
> cpm
         cell1     cell2
gene1  99009.9 151745.07
gene2 198019.8 273141.12
gene3 148514.9 242792.11
gene4 257425.7 271623.67
gene5 297029.7  60698.03

## 再求log2(cpm+1)
> log2cpm=log2(cpm+1)
> log2cpm
         cell1    cell2
gene1 16.59530 17.21130
gene2 17.59529 18.05929
gene3 17.18026 17.88937
gene4 17.97380 18.05126
gene5 18.18025 15.88939

## 写成一个函数
# 可以接受文件路径，或者counts矩阵
getNormalizedCts = function ( ctsPath, filename=T ) {
  if(filename==T){
    cts = read.table ( ctsPath , header = T , as.is = T )
  }else{
    cts=ctsPath
  }
  apply ( cts , 2 , function ( x ) { log2 ( ( 10^6 ) * x / sum ( x ) + 1 ) })
}
getNormalizedCts(x,F)
#          cell1    cell2
# gene1 16.59530 17.21130
# gene2 17.59529 18.05929
# gene3 17.18026 17.88937
# gene4 17.97380 18.05126
# gene5 18.18025 15.88939



## 更综合的例子
# 按列，求香农指数: -p*log(p)的累加和
getEntropy = function ( cts ) {
  #print(cts)
  prop=apply(cts, 2, function(x){ x/sum(x)})
  #print(prop)
  entropy = apply( -prop*log10(prop+1e-100), 2, sum )
  #
  df=data.frame(
    cid=names(entropy),
    entropy=as.numeric(entropy)
  )
  row.names(df)=df$cid
  #
  return(df)
}
> getEntropy(x)
        cid   entropy
cell1 cell1 0.6700153
cell2 cell2 0.6550746</div>
</div>





<br><a name="13"></a>
<h3 class="tutheader">apply中使用if</h3>
<p>我们可以在apply中加入条件判断。</p>

<div class="code notranslate">
	<div style="white-space: pre-wrap;"># 造一个需求: 对于每个基因，cell1/cell2 大于0.1，则返回cell1，否则返回cell2的表达量
# 方法1: if(){}else{}
apply(x, 1, function(x){
  if( x[1]/x[2] >0.1){
    return(x[1])
  }else{
    return(x[2])
  }
})
#Tips: 自定义函数中，输入变量是原数据框的一行或一列，如果要对其中一个元素操作，要加下标(R下标从1开始)。


# 方法2: ifelse(a>b, x, y)
apply(x, 1, function(x){
  ifelse( x[1]/x[2] >0.1, x[1], x[2])
})

# gene1 gene2 gene3 gene4 gene5 
#   100    20   160    26    30 </div>
</div>





















<br><a name="2"></a>
<h2 class="tutheader">lapply, 对list使用fn，并返回list (sapply返回矩阵)</h2>
<p>lapply returns a list of the same length as X, each element of which is the result of applying FUN to the corresponding element of X.</p>

<p>lapply函数是一个最基础循环操作函数之一，用来对list、data.frame数据集进行循环，并返回和X长度同样的list结构作为结果集，通过lapply的开头的第一个字母’l’就可以判断返回结果集的类型。</p>

<p>lapply就可以很方便地把list数据集进行循环操作，还可以用data.frame数据集按列进行循环，但如果传入的数据集是一个向量或矩阵对象，那么直接使用lapply就不能达到想要的效果了。</p>

<pre>函数定义：lapply(X, FUN, ...)
参数列表：
X:list、data.frame数据
FUN: 自定义的调用函数
…: 更多参数，可选
</pre>


<div class="code notranslate">
	<div style="white-space: pre-wrap;">lapply(mtcars, sum) #计算每一列的总和
# $mpg
# [1] 642.9
# 
# $cyl
# [1] 198
# ...

#因为数据框本质上也是列list
mtcars[[1]] #第一列
# [1] 21.0 21.0 22.8 21.4  ...</div>
</div>









<br><a name="22"></a>
<h3 class="tutheader">按照条件f拆分x: split(x, f, drop = FALSE, ...)</h3>
<p>split(1:10, 1:10), it means split the number 1 to 10 into 10 groups.</p>
<p>f: 函数，一个factor或者list（如果list中元素交互作用于分组中），以此为规则将x分组</p>
<p>drop: 逻辑值，如果f中的某一个level没有用上则被弃用</p>


<div class="code notranslate">
	<div style="white-space: pre-wrap;">#例1: 把1-10分成2组，则一组是奇数，一组是偶数
> split(1:10, 1:2)
$`1`
[1] 1 3 5 7 9

$`2`
[1]  2  4  6  8 10



#例2: 按照f拆分x: split(x, f, drop = FALSE, ...)
d = data.frame(gender=c("M","M","F","M","F","F"),
	age=c(47,59,21,32,33,24),
	income=c(55000,88000,32450,76500,123000,45650), 
	over25=rep(c(1,1,0), times=2))
d
#   gender age income over25
#1      M  47  55000      1
#2      M  59  88000      1
#3      F  21  32450      0
#4      M  32  76500      1
#5      F  33 123000      1
#6      F  24  45650      0

grps=split(d$income, list(d$gender,d$over25)) #将income按照gender、over25分组，2*2=4组
grps
# $F.0
# [1] 32450 45650
# 
# $M.0
# numeric(0)
# 
# $F.1
# [1] 123000
# 
# $M.1
# [1] 55000 88000 76500


lapply(grps, mean) #对list分别求平均
# $F.0
# [1] 39050
# 
# $M.0
# [1] NaN
# 
# $F.1
# [1] 123000
# 
# $M.1
# [1] 73166.67




# 例3: 年少多金组: 超过平均工资的一半，且低于25岁。组外组内。
split(d$income, d$income>0.5*mean(d$income) & d$age&lt;25)
# $`FALSE`
# [1]  55000  88000  32450  76500 123000
# 
# $`TRUE`
# [1] 45650</div>
</div>









<br><a name="23"></a>
<h3 class="tutheader">sapply函数返回矩阵(simple apply)</h3>
<p>sapply 函数是一个简化版的lapply，sapply增加了2个参数simplify和USE.NAMES，
主要就是让输出看起来更友好，返回值为向量，而不是list对象。</p>

<pre>
函数定义：sapply(X, FUN, ..., simplify=TRUE, USE.NAMES = TRUE)
参数列表：
X:数组、矩阵、数据框
FUN: 自定义的调用函数
…: 更多参数，可选
simplify: 是否数组化，当值array时，输出结果按数组进行分组
USE.NAMES: 如果X为字符串，TRUE设置字符串为数据名，FALSE不设置

simplify=F：返回值的类型是list，此时与lapply完全相同。
</pre>

<p>想要返回的结果是一个向量或矩阵，设置
simplify=T（默认值）：返回值的类型由计算结果定，如果函数返回值长度为1，则sapply将list简化为vector；
如果返回的列表中每个元素的长度都大于1且长度相同，那么sapply将其简化为一个矩阵。</p>


<div class="code notranslate">
	<div style="white-space: pre-wrap;"># 例1: 对数据框分组，求分组后每组的列平均值
## 对数据框的分组
head(airquality)
#   Ozone Solar.R Wind Temp Month Day
# 1    41     190  7.4   67     5   1
# 2    36     118  8.0   72     5   2

#按月份分组
airByMonth=split(airquality, airquality$Month) #airByMonth是一个list，每个元素是一个df
sapply(airByMonth, dim) #看每个分组的行列数
#      5  6  7  8  9 #月份
#[1,] 31 30 31 31 30 #行数
#[2,]  6  6  6  6  6 #列数

# 按月，求列的平均值 (apply家族函数逇嵌套)
lapply(airByMonth, 
  function(x){ #传入的参数是lapply输出的，是list中的每个元素，就是每个月份的数据框
    #apply(x,2,mean) #对这个数据框按列求平均数
    #去掉na再求平均值：na.rm=T
    apply(x,2,function(x){mean(x, na.rm=T)})
  }
)
# $`5`
#     Ozone   Solar.R      Wind      Temp     Month       Day 
#  23.61538 181.29630  11.62258  65.54839   5.00000  16.00000 
# 
# $`6`
#     Ozone   Solar.R      Wind      Temp     Month       Day 
#  29.44444 190.16667  10.26667  79.10000   6.00000  15.50000 

# lapply返回的是列表，如果想要表格形式
sapply(airByMonth, function(x){ apply(x,2,function(x){mean(x, na.rm=T)})} )
#或 求列mean更简短的函数
sapply(airByMonth, function(x){colMeans(x, na.rm=T)})
#                 5         6          7          8         9
# Ozone    23.61538  29.44444  59.115385  59.961538  31.44828
# Solar.R 181.29630 190.16667 216.483871 171.857143 167.43333
# Wind     11.62258  10.26667   8.941935   8.793548  10.18000
# Temp     65.54839  79.10000  83.903226  83.967742  76.90000
# Month     5.00000   6.00000   7.000000   8.000000   9.00000
# Day      16.00000  15.50000  16.000000  16.000000  15.50000

sapply(airByMonth, function(x){colMeans(x)}) #不加na.rm=T则结果中有NA
#                5         6          7         8        9
# Ozone         NA        NA         NA        NA       NA
# Solar.R       NA 190.16667 216.483871        NA 167.4333
# Wind    11.62258  10.26667   8.941935  8.793548  10.1800
# Temp    65.54839  79.10000  83.903226 83.967742  76.9000
# Month    5.00000   6.00000   7.000000  8.000000   9.0000
# Day     16.00000  15.50000  16.000000 16.000000  15.5000</div>
</div>









<br><a name="24"></a>
<h3 class="tutheader">vapply, 类似sapply，FUN.VALUE参数可控制返回值的行名</h3>
<p>vapply类似于sapply，提供了FUN.VALUE参数，用来控制返回值的行名，这样可以让程序更健壮。</p>
<p>sapply是lapply的友好版本，但可预测性不好。如果是大规模的数据处理，后续的类型判断工作会很麻烦而且很费时。vapply增加的FUN.VALUE参数可以直接对返回值类型进行检查，这样的好处是不仅运算速度快，而且程序运算更安全（因为结果可控）。</p>
<pre>
函数定义：vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)
参数列表：
X:数组、矩阵、数据框
FUN: 自定义的调用函数
FUN.VALUE: 定义返回值的行名row.names
…: 更多参数，可选
USE.NAMES: 如果X为字符串，TRUE设置字符串为数据名，FALSE不设置
</pre>

<p>通过使用vapply可以直接设置返回值的行名，这样子做其实可以节省一行的代码，让代码看起来更顺畅，当然如果不愿意多记一个函数，那么也可以直接忽略它，只用sapply就够了。</p>
<p>比如，对数据框的列数据进行累计求和，并对每一行设置行名row.names</p>



<div class="code notranslate">
	<div style="white-space: pre-wrap;">例1:df=mtcars[1:4,1:3];df
#                 mpg cyl disp
# Mazda RX4      21.0   6  160
# Mazda RX4 Wag  21.0   6  160
# Datsun 710     22.8   4  108
# Hornet 4 Drive 21.4   6  258

sapply(df,cumsum) #竖着累加
#       mpg cyl disp
# [1,] 21.0   6  160
# [2,] 42.0  12  320
# [3,] 64.8  16  428
# [4,] 86.2  22  686

vapply(df,cumsum, #添加列名，必须是这种带等号的，左边是列名，右边是类型
# 左边的列名可以省略，但是右边的类型名字必须有。
       FUN.VALUE=c('a'=0,'b'=0,'c'=0,'d'=0))
#    mpg cyl disp
# a 21.0   6  160
# b 42.0  12  320
# c 64.8  16  428
# d 86.2  22  686




例2: vapply比sapply安全?! 我感觉：对行的数据类型进行控制，好像不直观，不如对列的数据类型进行约束。
#按月份分组
airByMonth=split(airquality, airquality$Month) #airByMonth是一个list，每个元素是一个df
sapply(airByMonth, function(x){colMeans(x, na.rm=T)})
#                 5         6          7          8         9
# Ozone    23.61538  29.44444  59.115385  59.961538  31.44828
# Solar.R 181.29630 190.16667 216.483871 171.857143 167.43333
# Wind     11.62258  10.26667   8.941935   8.793548  10.18000
# Temp     65.54839  79.10000  83.903226  83.967742  76.90000
# Month     5.00000   6.00000   7.000000   8.000000   9.00000
# Day      16.00000  15.50000  16.000000  16.000000  15.50000


## 注意: FUN函数获得的结果和 FUN.VALUE 设置的不一致（长度和类型）都会出错
# 可以根据vapply函数的这一功能，使用FUN.VALUE参数对数据进行批量检测。
vapply(airByMonth, function(x){colMeans(x, na.rm=T)},
       FUN.VALUE = seq(1,6) )
#报错: values must be type 'integer',
#but FUN(X[[1]]) result is type 'double'

vapply(airByMonth, function(x){colMeans(x, na.rm=T)},
       FUN.VALUE = c(1,2,3,4,5,6.01) )
#把列名换为a,b,c...
vapply(airByMonth, function(x){colMeans(x, na.rm=T)},
       FUN.VALUE = c('a'=1, 'b'=1, 'c'=1, 'd'=1, 'e'=1, 'f'=1) )
#
#
# 把列名精简为前3个字母
rn=substr(colnames(airquality),1,3); rn
fv=seq(0.9,6);fv
names(fv)=rn;fv
# Ozo Sol Win Tem Mon Day 
# 0.9 1.9 2.9 3.9 4.9 5.9

vapply(airByMonth, function(x){colMeans(x, na.rm=T)},
       FUN.VALUE = fv )
#             5         6          7          8         9
# Ozo  23.61538  29.44444  59.115385  59.961538  31.44828
# Sol 181.29630 190.16667 216.483871 171.857143 167.43333
# Win  11.62258  10.26667   8.941935   8.793548  10.18000
# Tem  65.54839  79.10000  83.903226  83.967742  76.90000
# Mon   5.00000   6.00000   7.000000   8.000000   9.00000
# Day  16.00000  15.50000  16.000000  16.000000  15.50000</div>
</div>









<br><a name="25"></a>
<h3 class="tutheader">mapply, 是sapply的多变量版本，第一个参数是函数，后面能接收多个输入数据</h3>

















<br><a name="3"></a>
<h2 class="tutheader">tapply: table(), by() </h2>











<br><a name="31"></a>
<h3 class="tutheader">gl() 产生因子/函数table（求因子出现的频数）</h3>











<br><a name="32"></a>
<h3 class="tutheader">by(dataframe, INDICES, FUN, ..., simplify=TRUE)</h3>





















<br><a name="4"></a>
<h2 class="tutheader">rapply, 递归版本的lapply，只处理list类型数据</h2>














<br><a name="5"></a>
<h2 class="tutheader">eapply, 对环境内的所有变量批量(开发R包用)</h2>














			</div>
		</div>
		
		<div class="previous-next-links">
			<div class="previous-design-link"><i style="font-size:16px;" class="fa fa-arrow-left" aria-hidden="true"></i> <a href="/R/R-intro.html" rel="pre">R 简介</a> </div>
			<div class="next-design-link"><a href="/R/R-intro.html" rel="next"> R 简介</a> <i style="font-size:16px;" class="fa fa-arrow-right" aria-hidden="true"></i></div>
		</div>
	</div>
</div>







	
	
	
	
	










</div>

</div>

</body>
</html>